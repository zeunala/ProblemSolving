'''
파이프 옮기기 1

입력
첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)이 주어진다.
둘째 줄부터 N개의 줄에는 집의 상태가 주어진다.
빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.

출력
첫째 줄에 파이프의 한쪽 끝을 (N, N)으로 이동시키는 방법의 수를 출력한다.
이동시킬 수 없는 경우에는 0을 출력한다.
방법의 수는 항상 1,000,000보다 작거나 같다.
'''

'''
- 한 쪽 끝이 (1, 2)인 상태에서 (N, N)으로 이동시키게 만들어야 한다.
DP를 이용하여 각 상태에 대한 방법의 수를 구하자.
* Pass/1st/00:47:41
'''
from copy import deepcopy

N = int(input())
arr = []
for i in range(N):
    arr.append(list(map(int, input().split())))

# dp[c][a][b]는 한 쪽 끝을 (a, b)로 이동시키는 방법의 수 (편의상 0행 0열부터 시작한다고 하자)
# 이 때 c는 현재 파이프 모습으로 0은 가로, 1은 세로, 2는 대각선 방향으로 놓여있음을 의미한다.
dp = [[[0 for _ in range(N)] for _ in range(N)] for _ in range(3)]


# 우선 0행 부분과 2열 부분에 대한 방법의 수를 계산한 뒤 이들의 값을 이용해 나머지 부분을 계산하자
# 0행 부분은 무조건 오른쪽으로만 미는 경우뿐이므로 경우의 수가 0 또는 1이며, 2열부분도 대각선->세로 순으로 미는 경우 뿐으로 경우의 수가 0 또는 1이다.
for j in range(1, N):
    if arr[0][j] == 0: # 0행의 경우 처음 상태에서 오른쪽으로 이동하는 상황밖에 없으므로 목적지 중에 벽만 없으면 된다.
        dp[0][0][j] = 1
    else: # 벽이 있다면 그 공간을 포함해서 오른쪽으로 모두 방법의 수는 0이다.
        break

if arr[0][2] == 0 and arr[1][2] == 0 and arr[1][1] == 0:
    dp[2][1][2] == 1 # 처음에 대각선으로 가는 경우
    for i in range(2, N):
        if arr[i][2] == 0: # 이후 계속 세로로 가는 경우
            dp[1][i][2] == 1
        else:
            break

for i in range(1, N): # 나머지 경우에 대해 1행부터 갱신한다.
    for j in range(1, N):
        # dp[0][i][j]의 경우. 즉 가로 방향으로 (i, j)에 도달
        if arr[i][j] == 0: # 당연히 (i, j)에 벽이 없어야 한다.
            dp[0][i][j] = dp[0][i][j-1] + dp[2][i][j-1] # 마지막으로 오른쪽으로 이동, 이 때 직전 상태는 가로or대각선이어야 한다.

        # dp[1][i][j]의 경우. 즉 세로 방향으로 (i, j)에 도달
        if arr[i][j] == 0:
            dp[1][i][j] = dp[1][i-1][j] + dp[2][i-1][j] # 마지막으로 아래로 이동, 이 때 직전 상태는 세로or대각선이어야 한다.

        # dp[2][i][j]의 경우. 즉 대각선 방향으로 (i,j)에 도달
        if arr[i][j] == 0 and arr[i-1][j] == 0 and arr[i][j-1] == 0: # 이동 중 벽이 없어야 한다.
            dp[2][i][j] = dp[0][i-1][j-1] + dp[1][i-1][j-1] + dp[2][i-1][j-1] # 마지막으로 대각선 이동, 직전 상태는 상관없다.

print(dp[0][N-1][N-1]+dp[1][N-1][N-1]+dp[2][N-1][N-1])